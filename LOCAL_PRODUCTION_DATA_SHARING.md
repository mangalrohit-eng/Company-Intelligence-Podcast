# Local vs Production Data Sharing

## Current Situation

**By default, local development CANNOT see episodes generated by the load balancer (production).**

### Why?

| Data Type | Local Storage | Production Storage |
|-----------|--------------|-------------------|
| **Runs/Episodes** | `data/runs.json` (local file) | DynamoDB `runs` table |
| **Audio Files** | `output/episodes/` (local disk) | S3 bucket |
| **Podcasts** | DynamoDB (with fallback) | DynamoDB |

### The Problem

1. **Runs API** (`/api/podcasts/[id]/runs`) only reads from:
   - Local file: `data/runs.json`
   - Local file system: `output/episodes/` folder
   - **Does NOT check DynamoDB**

2. **Podcasts API** (`/api/podcasts`) DOES check DynamoDB:
   - Tries DynamoDB first
   - Falls back gracefully if not available
   - **This works for podcasts, but not for runs**

---

## Solutions

### Option 1: Make Local Read from Production DynamoDB (Recommended)

Update the runs API to check DynamoDB like the podcasts API does.

**File:** `src/app/api/podcasts/[id]/runs/route.ts`

**Change:** Add DynamoDB check before local file check:

```typescript
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const podcastId = params.id;
    
    let runs: PersistedRun[] = [];
    
    // Try DynamoDB first (production data)
    try {
      const { DynamoDBClient } = await import('@aws-sdk/client-dynamodb');
      const { DynamoDBDocumentClient, QueryCommand } = await import('@aws-sdk/lib-dynamodb');
      
      const client = new DynamoDBClient({ 
        region: process.env.AWS_REGION || 'us-east-1' 
      });
      const docClient = DynamoDBDocumentClient.from(client);
      
      const response = await docClient.send(
        new QueryCommand({
          TableName: process.env.RUNS_TABLE || 'runs',
          IndexName: 'PodcastIdIndex',
          KeyConditionExpression: 'podcastId = :podcastId',
          ExpressionAttributeValues: {
            ':podcastId': podcastId,
          },
        })
      );
      
      runs = (response.Items || []) as PersistedRun[];
      console.log(`[Runs API] Loaded ${runs.length} runs from DynamoDB`);
    } catch (dynamoError: any) {
      console.warn('[Runs API] DynamoDB not available, using local storage:', dynamoError.message);
      // Fall through to local file check
    }
    
    // If no runs from DynamoDB, try local file (development)
    if (runs.length === 0) {
      runs = await getRunsForPodcast(podcastId);
      console.log(`[Runs API] Loaded ${runs.length} runs from local file`);
    }
    
    // ... rest of existing code (merge memory runs, file system check, etc.)
  }
}
```

**Result:** Local will see production episodes if:
- AWS credentials are configured locally
- `AWS_REGION` is set in `.env`
- `RUNS_TABLE` environment variable is set (or defaults to 'runs')

---

### Option 2: Use Production API Endpoint from Local

Point your local frontend to the production API.

**File:** `.env` (local)

```bash
# Point to production API
NEXT_PUBLIC_API_URL=https://your-load-balancer-url/api
# or
NEXT_PUBLIC_API_URL=https://54xpwhf7jd.execute-api.us-east-1.amazonaws.com
```

**Result:** Local frontend will show production data, but you won't be able to test local changes.

---

### Option 3: Keep Separate (Current Behavior)

**Pros:**
- Clean separation between dev and prod
- No risk of accidentally modifying production data
- Faster local development (no AWS calls)

**Cons:**
- Can't see production episodes locally
- Need to switch between environments

---

## Recommended Approach

**Use Option 1** - Make local read from DynamoDB with fallback:

1. ✅ Local can see production episodes
2. ✅ Still works offline (falls back to local file)
3. ✅ No risk (read-only from DynamoDB)
4. ✅ Best of both worlds

### Setup Required

**For local to read production DynamoDB:**

1. **Configure AWS credentials:**
   ```bash
   aws configure
   # Or set in .env:
   AWS_ACCESS_KEY_ID=your-key
   AWS_SECRET_ACCESS_KEY=your-secret
   AWS_REGION=us-east-1
   ```

2. **Set DynamoDB table name (optional):**
   ```bash
   # In .env:
   RUNS_TABLE=runs
   ```

3. **That's it!** The code will automatically:
   - Try DynamoDB first (production data)
   - Fall back to local file if DynamoDB unavailable
   - Still check local file system for audio files

---

## Audio Files

Even if runs are loaded from DynamoDB, audio files still need to be accessible:

### Current Behavior:
- Local: Serves from `output/episodes/` folder
- Production: Serves from S3/CloudFront

### To See Production Audio Locally:

The serve-file API already has S3 fallback! Just configure:

```bash
# .env
AWS_REGION=us-east-1
S3_BUCKET_NAME=podcast-platform-media-098478926952
CLOUDFRONT_DOMAIN=dhycfwg0k4xij.cloudfront.net
```

**How it works:**
1. Checks local file first → if not found
2. Checks S3/CloudFront → serves from production

---

## Summary

| Scenario | Runs Visible? | Audio Playable? |
|----------|--------------|----------------|
| **Current (separate)** | ❌ No | ❌ No |
| **Option 1 (DynamoDB + S3)** | ✅ Yes | ✅ Yes |
| **Option 2 (Production API)** | ✅ Yes | ✅ Yes |
| **Option 3 (Keep separate)** | ❌ No | ❌ No |

**Recommendation:** Implement Option 1 for the best developer experience.

